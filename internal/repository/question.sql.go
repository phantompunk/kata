// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: question.sql

package repository

import (
	"context"
	"database/sql"
)

const create = `-- name: Create :one
INSERT INTO questions (
  question_id, submit_id, title, title_slug, difficulty, function_name, content, code_snippets, test_cases, created_at
) VALUES (
  ?, ?, ?, ?, ?, ?, ?, ?, ?, ? 
) ON CONFLICT(question_id) DO UPDATE SET
    title       = excluded.title,
    title_slug  = excluded.title_slug,
    difficulty  = excluded.difficulty,
    created_at  = excluded.created_at
RETURNING question_id, title, title_slug, difficulty, function_name, content, code_snippets, test_cases, created_at, submit_id
`

type CreateParams struct {
	QuestionID   int64
	SubmitID     sql.NullInt64
	Title        string
	TitleSlug    string
	Difficulty   string
	FunctionName string
	Content      string
	CodeSnippets string
	TestCases    string
	CreatedAt    string
}

func (q *Queries) Create(ctx context.Context, arg CreateParams) (Question, error) {
	row := q.db.QueryRowContext(ctx, create,
		arg.QuestionID,
		arg.SubmitID,
		arg.Title,
		arg.TitleSlug,
		arg.Difficulty,
		arg.FunctionName,
		arg.Content,
		arg.CodeSnippets,
		arg.TestCases,
		arg.CreatedAt,
	)
	var i Question
	err := row.Scan(
		&i.QuestionID,
		&i.Title,
		&i.TitleSlug,
		&i.Difficulty,
		&i.FunctionName,
		&i.Content,
		&i.CodeSnippets,
		&i.TestCases,
		&i.CreatedAt,
		&i.SubmitID,
	)
	return i, err
}

const exists = `-- name: Exists :one
SELECT EXISTS (
  SELECT 1 FROM questions
  WHERE title_slug = ?
)
`

func (q *Queries) Exists(ctx context.Context, titleSlug string) (int64, error) {
	row := q.db.QueryRowContext(ctx, exists, titleSlug)
	var column_1 int64
	err := row.Scan(&column_1)
	return column_1, err
}

const getByID = `-- name: GetByID :one
SELECT question_id, title, title_slug, difficulty, function_name, content, code_snippets, test_cases, created_at, submit_id FROM questions
WHERE question_id = ? LIMIT 1
`

func (q *Queries) GetByID(ctx context.Context, questionID int64) (Question, error) {
	row := q.db.QueryRowContext(ctx, getByID, questionID)
	var i Question
	err := row.Scan(
		&i.QuestionID,
		&i.Title,
		&i.TitleSlug,
		&i.Difficulty,
		&i.FunctionName,
		&i.Content,
		&i.CodeSnippets,
		&i.TestCases,
		&i.CreatedAt,
		&i.SubmitID,
	)
	return i, err
}

const getBySlug = `-- name: GetBySlug :one
SELECT question_id, title, title_slug, difficulty, function_name, content, code_snippets, test_cases, created_at, submit_id FROM questions
WHERE title_slug = ? LIMIT 1
`

func (q *Queries) GetBySlug(ctx context.Context, titleSlug string) (Question, error) {
	row := q.db.QueryRowContext(ctx, getBySlug, titleSlug)
	var i Question
	err := row.Scan(
		&i.QuestionID,
		&i.Title,
		&i.TitleSlug,
		&i.Difficulty,
		&i.FunctionName,
		&i.Content,
		&i.CodeSnippets,
		&i.TestCases,
		&i.CreatedAt,
		&i.SubmitID,
	)
	return i, err
}

const getRandom = `-- name: GetRandom :one
SELECT q.question_id, q.title, q.title_slug, q.difficulty,
  CASE
      WHEN s.solved = 1 THEN 'Completed'
      ELSE 'Attempted'
  END AS status,
  COALESCE(s.last_attempted, q.created_at) AS last_attempted
FROM questions q
LEFT JOIN submissions s ON s.question_id = q.question_id
WHERE q.question_id = (
  SELECT question_id FROM questions
  ORDER BY RANDOM()
  LIMIT 1
) LIMIT 1
`

type GetRandomRow struct {
	QuestionID    int64
	Title         string
	TitleSlug     string
	Difficulty    string
	Status        string
	LastAttempted string
}

func (q *Queries) GetRandom(ctx context.Context) (GetRandomRow, error) {
	row := q.db.QueryRowContext(ctx, getRandom)
	var i GetRandomRow
	err := row.Scan(
		&i.QuestionID,
		&i.Title,
		&i.TitleSlug,
		&i.Difficulty,
		&i.Status,
		&i.LastAttempted,
	)
	return i, err
}

const getRandomWeighted = `-- name: GetRandomWeighted :one
SELECT q.question_id, q.title, q.title_slug, q.difficulty,
  CASE WHEN s.solved = 1 THEN 'Completed' ELSE 'Attempted' END AS status,
  COALESCE(s.last_attempted, q.created_at) AS last_attempted,
  (
    CAST(julianday('now') - julianday(COALESCE(s.last_attempted, q.created_at)) AS REAL) * 0.4 +
    COALESCE(s.failed_attempts, 0) * 0.3 +
    CASE q.difficulty WHEN 'Easy' THEN 0.3 WHEN 'Medium' THEN 0.6 ELSE 1.0 END * 0.2 +
    CASE WHEN COALESCE(s.times_solved, 0) = 1 THEN 0.1 ELSE 0.0 END
  ) AS weight_score
FROM questions q
LEFT JOIN submissions s ON s.question_id = q.question_id
ORDER BY weight_score DESC, RANDOM()
LIMIT 1
`

type GetRandomWeightedRow struct {
	QuestionID    int64
	Title         string
	TitleSlug     string
	Difficulty    string
	Status        string
	LastAttempted string
	WeightScore   interface{}
}

func (q *Queries) GetRandomWeighted(ctx context.Context) (GetRandomWeightedRow, error) {
	row := q.db.QueryRowContext(ctx, getRandomWeighted)
	var i GetRandomWeightedRow
	err := row.Scan(
		&i.QuestionID,
		&i.Title,
		&i.TitleSlug,
		&i.Difficulty,
		&i.Status,
		&i.LastAttempted,
		&i.WeightScore,
	)
	return i, err
}

const getStats = `-- name: GetStats :one
SELECT
    COUNT(DISTINCT q.question_id) AS attempted,
    COUNT(DISTINCT CASE WHEN s.solved = 1 THEN s.question_id END) AS completed
FROM questions q
LEFT JOIN submissions s on q.question_id = s.question_id
`

type GetStatsRow struct {
	Attempted int64
	Completed int64
}

func (q *Queries) GetStats(ctx context.Context) (GetStatsRow, error) {
	row := q.db.QueryRowContext(ctx, getStats)
	var i GetStatsRow
	err := row.Scan(&i.Attempted, &i.Completed)
	return i, err
}

const incrementFailedAttempts = `-- name: IncrementFailedAttempts :exec
UPDATE submissions
SET failed_attempts = failed_attempts + 1, last_attempted = ?
WHERE question_id = ? AND lang_slug = ?
`

type IncrementFailedAttemptsParams struct {
	LastAttempted string
	QuestionID    int64
	LangSlug      string
}

func (q *Queries) IncrementFailedAttempts(ctx context.Context, arg IncrementFailedAttemptsParams) error {
	_, err := q.db.ExecContext(ctx, incrementFailedAttempts, arg.LastAttempted, arg.QuestionID, arg.LangSlug)
	return err
}

const incrementTimesSolved = `-- name: IncrementTimesSolved :exec
UPDATE submissions
SET times_solved = times_solved + 1, solved = 1, last_attempted = ?
WHERE question_id = ? AND lang_slug = ?
`

type IncrementTimesSolvedParams struct {
	LastAttempted string
	QuestionID    int64
	LangSlug      string
}

func (q *Queries) IncrementTimesSolved(ctx context.Context, arg IncrementTimesSolvedParams) error {
	_, err := q.db.ExecContext(ctx, incrementTimesSolved, arg.LastAttempted, arg.QuestionID, arg.LangSlug)
	return err
}

const listAll = `-- name: ListAll :many
SELECT question_id, title, title_slug, difficulty, function_name, content, code_snippets, test_cases, created_at, submit_id FROM questions
ORDER BY question_id ASC
`

func (q *Queries) ListAll(ctx context.Context) ([]Question, error) {
	rows, err := q.db.QueryContext(ctx, listAll)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Question
	for rows.Next() {
		var i Question
		if err := rows.Scan(
			&i.QuestionID,
			&i.Title,
			&i.TitleSlug,
			&i.Difficulty,
			&i.FunctionName,
			&i.Content,
			&i.CodeSnippets,
			&i.TestCases,
			&i.CreatedAt,
			&i.SubmitID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const submit = `-- name: Submit :one
INSERT INTO submissions (
  question_id, lang_slug, solved, last_attempted
) VALUES (
  ?, ?, ?, ? 
) ON CONFLICT(question_id, lang_slug) DO UPDATE SET
    solved  = excluded.solved,
    last_attempted  = excluded.last_attempted
RETURNING id, question_id, lang_slug, solved, last_attempted, failed_attempts, times_solved
`

type SubmitParams struct {
	QuestionID    int64
	LangSlug      string
	Solved        int64
	LastAttempted string
}

func (q *Queries) Submit(ctx context.Context, arg SubmitParams) (Submission, error) {
	row := q.db.QueryRowContext(ctx, submit,
		arg.QuestionID,
		arg.LangSlug,
		arg.Solved,
		arg.LastAttempted,
	)
	var i Submission
	err := row.Scan(
		&i.ID,
		&i.QuestionID,
		&i.LangSlug,
		&i.Solved,
		&i.LastAttempted,
		&i.FailedAttempts,
		&i.TimesSolved,
	)
	return i, err
}
